Hew pretty close to Linux/Posix.

file descriptors refer to a table of open file descriptions

open file descriptions can appear in multiple places in the fd table, and for multiple processes.
Share the same memory for these. Ex: fdtable = [{ofd}, {ofd}, ...]
open file descriptions store an offset.

representation of non-open files (inodes):
for directories, lookup children
for files, open (= turn into open file description)
file type: regular file, directory, (character) device, named pipe, symbolic link, socket.
owner, permissions, timestamps.
supposed to be in-sync with the permanent storage. Don't let two copies get out of sync.
id number unique to filesystem

splicing together filesystems needs a bit more thought, though Linux probably has it right
in Linux, it looks like you keep a table of mount points (roughly inodes) and the mounted filesystem
so that you can handle transitions as a step separate from in-filesystem lookup of children.

Files are identified by pair of filesystem instance and fs-instance-unique identifier (= device number).
The only way to travel between filesystems is by going through a mount point:
a mount point maps an (empty? maybe not necessarily) directory in one filesystem
onto (the root?) of another file system.

Bind mounts are cool, track root per-mount.
Require a mount of the underlying filesystem, and don't allow unmount until all bind mounts are unmounted
(or take the bind mounts down together).

Filesystems need to maintain the root directory specially (implicit link).
By not allowing hard links to directories, we preserve the tree structure of file systems.
Thus we do not have to worry about loops., and can use simple refcounting for garbage collection.
Keep an orphan list for files with nlink=0 but still open in some process; process this list on mount,
and refuse unmount with this list not empty (or non-orphaned processes still having open files on the fs).

Will need to design a filesystem on top of IndexedDB.
Look at https://github.com/filerjs/filer, see if it works for our purposes.
Another possibility is https://github.com/jvilk/BrowserFS.
Both of these are not currently maintained.
IndexedDB is shared between tabs in the same origin; need some form of concurrency control.
Use Web Locks API (Chrome only for now) https://developer.mozilla.org/en-US/docs/Web/API/Web_Locks_API
Use a modified seqlock: make sure each transaction leaves the filesystem in a consistent state, such
that it could be removed from one tab and shifted to another.
When attaching to the fs, increment a counter, and store the value. As long as the counter stays at
this value, the filesystem has not been changed except by this tab, so all cached data remains consistent.
In each transaction, read the counter, abort if it is different than expected, raising a "fs lost" error.
When we lose the filesystem, we can get it back by incrementing the counter again, but we have to clear
any cached preconceptions about the state of the filesystem.
This system can probably be enhanced to provide a middle ground where some cached data can be kept.
(Such as, increment a counter whenever the directory tree changes, but not when files are written.)

---

Linux adds some more guarantees to POSIX for non-interruptability of reads and writes.
Torvalds rant: https://yarchive.net/comp/linux/wakekill.html
For a normal file with at least n bytes before EOF, read will read all n requested bytes.
For a normal file opened with O_APPEND, writes (at least short enough ones) will write all n requested bytes contiguously.
(No short reads or writes.)

---

POSIX fcntl locking (F_SET_LK) is pretty much broken. https://lwn.net/Articles/586904/
BSD flock is much better, lacking byte-range locks.
Above article proposes fcntl OFD-local locks with similar semantics to BSD.
Lock files are filesystem based, and rely on atomicity guarantees of certain operations.

---

Regular files, directories, symbolic links, and fifos should be supported by normal file systems.
That leaves device files and sockets. (Possibly also message queues, semaphores, shared memory objects, typed memory objects)

Say there is a unique filesystem that holds devices. dev_t and ino_t are the same size (uint64_t), so we can't just embed,
but we can allocate inodes to devices (uniquely identified by dev_t), and keep track of the backwards mapping as well, while
also having inodes for directories (and symlinks?)

We don't actually have many devices: go with completely static device numbers?
For unix sockets, prefer linux abstract namespace, possibly with a filesystem view.

Keep it simple: store both device files and sockets in normal file systems. (Though they may be of limited utility.) Prioritize supporting them in tempfs.

Normal file operations (fs layer):
read at position
write at position
get file length
append (atomic seek to end and write)

(vfs layer):
current position
seek

(fs layer)
create a new file
create a hard link
remove a hard link

---

Need to refcount open file descriptions.

---

close should return EINTR if fd still valid and interrupted by signal, EINPROGRESS if fd closed but interrupted by signal

---

Mounts form a tree structure, which induces a tree structure for the complete file hierarchy.
cwd/root for a process are effectively pairs of mount and identifier.

A filesystem consists of a tree of directories along with a set of non-directory files, which can be linked from multiple directories.
Persistant filesystems should keep track of files with open file descriptions but no links. Consider how this works for directories.
POSIX says orphaned directories must be empty, they have no . or .. links, and you cannot create new entries in the directory.
Or just return EBUSY.

Distinct filesystems contain distinct files. Use Web Locks API for persistent filesystems.
The amalgamated file tree consists of a tree of mounts, each mount points to a filesystem (multiple mounts may point to the same filesystem),
Mounts also track a path inside the filesystem to the effective root. This path (from the real root of the filesystem),
the links in the path, should be pinned by the filesystem; the path should not change while the mount is alive.
A similar thing should happen for the mount point/the parent mount.

So filesystems have two kinds of pinned paths: paths from the root to the effective root of one of their mounts, and for each child mount
of one of this filesystem's mounts a path from the effective root to the mount point. Pinning orphaned files/directories is a bit weird, but plausible.
Do we have to do the pinning down from the root of the filesystem, or can we start in the middle and ask to pin this file here?

--

An alternative that may be simpler to implement:
Mount inodes onto inodes.
In a filesystem, you have the natural root, and you also have a bunch of files which are being used as mount roots.
When a directory is mounted, it can be moved around freely, but can only be unlinked when it is empty. Unlinking a mounted directory removes the virtual mounting link.
So the idea is that rm -rf mountpoint clears all the files in the mounted filesystem below the mount root, does not unlink the mount root (leaves an empty directory), and unmounts.
If a file is mounted, rm mountpoint simply removes the mount. Mounts thus act as high-priority virtual links, that can go across filesystems.
Mounts still form a tree, each with their own independent set of child mounts.
